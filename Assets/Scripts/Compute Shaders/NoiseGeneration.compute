// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel NoiseDensity

//includes
#include "Assets/Scripts/Include/Noise.compute"

// Noise settings
//StructuredBuffer<float3> offsets;
RWStructuredBuffer<float4> voxelPoints;
uint VoxelsPerAxis;
float3 chunkCentre;
float voxelSpacing;
float chunkSize;
float3 offset;

int octaves;
float lacunarity;
float persistence;
float hurstExponent;
float noiseScale;
float noiseWeight;
float floorOffset;
float weightMultiplier;
//bool closeEdges;
float hardFloor;
float hardFloorWeight;


//helper function
int indexFromCoord(uint x, uint y, uint z) {
	return z * VoxelsPerAxis * VoxelsPerAxis + y * VoxelsPerAxis + x;
}

[numthreads(8,8,8)]
void NoiseDensity(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= VoxelsPerAxis || id.y >= VoxelsPerAxis || id.z >= VoxelsPerAxis) {
		return;
	}

	float3 pos = chunkCentre + id * voxelSpacing - chunkSize / 2;
	float offsetNoise = 0;

	float noise = 0;

	float frequency = noiseScale / 100;
	float amplitude = 1;
	float weight = 1;
	for (int j = 0; j < octaves; j++) {
		float n = snoise(pos * frequency + offset);
		float v = 1 - abs(n);
		v = v * v;
		v *= weight;
		weight = max(min(v * weightMultiplier, 1), 0);
		noise += v * amplitude;
		amplitude *= persistence;
		frequency *= lacunarity;
	}

	float finalVal = -(pos.y + floorOffset) + noise * noiseWeight;

	if (pos.y < hardFloor) {
		finalVal += hardFloorWeight;
	}

	/*if (closeEdges) {
		float3 edgeOffset = abs(pos * 2) - worldSize + spacing / 2;
		float edgeWeight = saturate(sign(max(max(edgeOffset.x, edgeOffset.y), edgeOffset.z)));
		finalVal = finalVal * (1 - edgeWeight) - 100 * edgeWeight;

	}*/

	int index = indexFromCoord(id.x, id.y, id.z);
	voxelPoints[index] = float4(pos, finalVal);

}

